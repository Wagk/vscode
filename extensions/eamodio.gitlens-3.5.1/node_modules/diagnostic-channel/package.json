{
  "_args": [
    [
      {
        "raw": "diagnostic-channel@0.1.0",
        "scope": null,
        "escapedName": "diagnostic-channel",
        "name": "diagnostic-channel",
        "rawSpec": "0.1.0",
        "spec": "0.1.0",
        "type": "version"
      },
      "C:\\Users\\Eric\\code\\vscode-gitlens\\node_modules\\applicationinsights"
    ]
  ],
  "_from": "diagnostic-channel@0.1.0",
  "_id": "diagnostic-channel@0.1.0",
  "_inCache": true,
  "_location": "/diagnostic-channel",
  "_nodeVersion": "7.7.4",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/diagnostic-channel-0.1.0.tgz_1493939395456_0.8265960759017617"
  },
  "_npmUser": {
    "name": "jithomso",
    "email": "jithomso@microsoft.com"
  },
  "_npmVersion": "4.1.2",
  "_phantomChildren": {},
  "_requested": {
    "raw": "diagnostic-channel@0.1.0",
    "scope": null,
    "escapedName": "diagnostic-channel",
    "name": "diagnostic-channel",
    "rawSpec": "0.1.0",
    "spec": "0.1.0",
    "type": "version"
  },
  "_requiredBy": [
    "/applicationinsights"
  ],
  "_resolved": "https://registry.npmjs.org/diagnostic-channel/-/diagnostic-channel-0.1.0.tgz",
  "_shasum": "7a6ad8ad5066bac544da0a379ba174ba362a57cf",
  "_shrinkwrap": null,
  "_spec": "diagnostic-channel@0.1.0",
  "_where": "C:\\Users\\Eric\\code\\vscode-gitlens\\node_modules\\applicationinsights",
  "dependencies": {
    "semver": "^5.3.0"
  },
  "description": "This package is intended to connect event 'publishers' to event 'subscribers' in such a way that the 'context' of the event is preserved. The exact nature of 'context' is deliberately left unspecified.",
  "devDependencies": {
    "@types/mocha": "^2.2.40",
    "@types/node": "^7.0.12",
    "mocha": "^3.2.0",
    "rimraf": "^2.6.1",
    "tslint": "^5.0.0",
    "typescript": "^2.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "7a6ad8ad5066bac544da0a379ba174ba362a57cf",
    "tarball": "https://registry.npmjs.org/diagnostic-channel/-/diagnostic-channel-0.1.0.tgz"
  },
  "files": [
    ".dist/*.d.ts",
    ".dist/*.js",
    "LICENSE",
    "README.md",
    "package.json"
  ],
  "license": "MIT",
  "main": "./.dist/channel.js",
  "maintainers": [
    {
      "name": "jithomso",
      "email": "jithomso@microsoft.com"
    },
    {
      "name": "joshgav",
      "email": "josh.gavant@outlook.com"
    },
    {
      "name": "microsoft",
      "email": "npmjs@microsoft.com"
    },
    {
      "name": "mike-kaufman",
      "email": "mkaufman@microsoft.com"
    },
    {
      "name": "osvaldorosado",
      "email": "osvaldo@osvaldojr.com"
    }
  ],
  "name": "diagnostic-channel",
  "optionalDependencies": {},
  "readme": "# Node Diagnostic-Channel\r\n\r\nThis package is intended to connect event 'publishers' to event 'subscribers' in such a way that the 'context' of the event is preserved. The exact nature of 'context' is deliberately left unspecified.\r\n\r\n## Example Usage\r\n\r\n### Subscriber\r\n\r\nSubscribing to an event is simple:\r\n\r\n```js\r\nvar channel = require('diagnostic-channel');\r\n\r\nchannel.subscribe('someEvent', function (event) {\r\n    // do something about the event\r\n});\r\n```\r\n\r\nThe contents of the `event` parameter to the subscribe callback is determined entirely by the publisher.\r\n\r\n### Publisher\r\n\r\nPublishing an event can be simple:\r\n\r\n```js\r\nvar channel = require('diagnostic-channel');\r\n\r\nchannel.publish('someEvent', someData);\r\n```\r\n\r\nIn many cases, preserving context may require some additional effort:\r\n\r\n```js\r\nvar channel = require('diagnostic-channel');\r\n\r\nfunction doWork(args, callback) {\r\n    // In some context...\r\n    doBatchedAsyncWork(args, channel.bindToContext((result) => {\r\n        channel.publish('someEvent', {result: result});\r\n        callback(result);\r\n    }))\r\n}\r\n```\r\n\r\n## API\r\n\r\n### Subscribe\r\n\r\n`channel.subscribe(name: string, callback: (event: any) => void): void`\r\n\r\nRegister the callback to be called when `publish` is invoked with a matching name. The callback will be given the data that is passed to the `publish` call.\r\n\r\nIf the callback throws an error, it will be silently ignored. If the callback modifies the event object, any subsequent subscribers will see the modified object, and it may also impact the original code's execution.\r\n\r\n### Publish\r\n\r\n`channel.publish(name: string, event: any): void`\r\n\r\nTrigger each subscribed callback for the same named event, passing the event object to each.\r\n\r\nSubscribers may modify the event object.\r\n\r\n### Unsubscribe\r\n\r\n`channel.unsubscribe(name: string, callback: (event: any) => void): void`\r\n\r\nRemove a previously registered callback from the named event. This uses function equality so it must be a reference to the same function, not an equivalent function.\r\n\r\n### addContextPreservation\r\n\r\n`channel.addContextPreservation(preserver: (callback: Function) => Function)`\r\n\r\nPushes the provided context preservation function onto a 'stack' of functions to preserve context.\r\n\r\nThe context preservation function `preserver` should track the context at the time it is invoked, and return a function that restores the preserved context, forwards its arguments to `callback`, returns the context to before this function was called, then returns the result of `callback`.\r\n\r\nA simple example preserving the Zone.js context:\r\n\r\n```js\r\nchannel.addContextPreservation((callback) => {\r\n    return Zone.current.wrap(callback);\r\n});\r\n```\r\n\r\nFor a more general contrived example, where the 'context' is a global object called `context`:\r\n\r\n```js\r\nvar context = { value: 1 };\r\n\r\nchannel.addContextPreservation((callback) => {\r\n    var preservedContext = context;\r\n    return function () {\r\n        var priorContext = context;\r\n        context = preservedContext;\r\n        var result = callback.apply(this, arguments);\r\n        context = priorContext;\r\n        return result;\r\n    }\r\n});\r\n```\r\n\r\n### bindToContext\r\n\r\n`channel.bindToContext(callback: Function)`\r\n\r\nReturns a function which will call the callback after applying each of the registered context preservation functions, and return the result of the callback after unwinding each of the context preservation functions.\r\n\r\nFor example, when using Zone.js:\r\n\r\n```js\r\nchannel.addContextPreservation((callback) => Zone.current.wrap(callback));\r\n\r\nvar z1 = Zone.current.fork({name: 'zone 1'});\r\nvar z2 = Zone.current.fork({name: 'zone 2'});\r\n\r\nvar z1BoundFunc = z1.run(() => channel.bindToContext(() => Zone.current.name));\r\n\r\nvar result = z2.run(() => z1BoundFunc());\r\n```\r\n\r\nBecause the function was bound in `zone 1`, `result` will be `zone 1`.\r\n\r\n### registerMonkeyPatch\r\n\r\n`channel.registerMonkeyPatch(packageName: string, patcher: {versionSpecifier: string, patch: (any, path: string) => any})`;\r\n\r\nIn order to inject publishing and context preservation behavior into third party libraries, we support monkey patching libraries as they are `require`'d.\r\n\r\nCalling this function will register a candidate monkey patcher to be applied when a future `require(packageName)` is called. If the package's version is a semver match for the `versionSpecifier` range, then the original object for that package is passed to the `patch` function, along with the path to the module, and the `patch` function should return a patched version which will end up as the result of the `require`.\r\n\r\nFor a simple example where we patch a `doSomethingAsync` method of the `foo` module to preserve the current context when invoking a callback:\r\n\r\n```js\r\nfunction patchFunction(originalPackage, packagePath) {\r\n    var originalFooAsync = foo.doSomethingAsync;\r\n    foo.doSomethingAsync = function () {\r\n        var callback = arguments[arguments.length-1];\r\n        if (callback && typeof callback == 'function') {\r\n            arguments[arguments.length-1] = channel.bindToContext(callback);\r\n        }\r\n        return originalFooAsync.apply(this, arguments);\r\n    }\r\n    return originalPackage;\r\n}\r\n\r\nvar patcher = {\r\n    versionSpecifier: \">= 1.0.0 < 2.0.0\",\r\n    patch: patchFunction\r\n};\r\n\r\nchannel.registerMonkeyPatch('foo', patcher);\r\n\r\nvar foo = require('foo');\r\n// Now foo.doSomethingAsync will be the patched version, assuming that the version of the foo package found by require() falls within the 1.0.0 - 2.0.0 range.\r\n```\r\n\r\n### autoLoadPackages\r\n\r\n`channel.autoLoadPackages(projectRoot: string)`\r\n\r\nAttempt to automatically discover and `require()` any publisher or subscriber packages present in the project.\r\n\r\nSpecifically, inspect every package in the `dependencies` of `projectRoot/package.json` and see whether they have a `pubsubAutoLoad` key set to a truthy value in their own package.json\r\n\r\nThis is so you do not need to explcitly\r\n```js\r\nrequire('mongodb-pub'); require('mongodb-sub'); require('redis-pub'); require('redis-sub');\r\n// ...\r\n``` \r\n\r\nin your code, you just need to specify them in the package.json so they are installed, and then invoke this function. ",
  "readmeFilename": "README.md",
  "scripts": {
    "build": "tsc --outDir ./.dist",
    "clean": "rimraf ./.dist",
    "lint": "tslint -c tslint.json -p tsconfig.json",
    "prepublish": "npm run lint && npm run build",
    "test": "npm run build && mocha ./.dist/tests/**/*.js"
  },
  "types": "./.dist/channel.d.ts",
  "version": "0.1.0"
}
